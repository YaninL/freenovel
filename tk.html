<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta property="description" content="" />
<link rel="stylesheet" href="asset/semantic.min.css" />
<link rel="stylesheet" href="asset/style.css" />
<script src="asset/FileSaver.min.js"></script>
<script src="asset/jszip.min.js"></script>
<title>TK Gen</title>
</head>
<body>

<div class="pusher">
<div class="page-header">
<div class="ui title container">
<h1> </h1>
</div>

<div class="ui one column grid page-header-menu">
<div class="ui attached secondary inverted menu computer only column">
  <div class="ui container">
    <div class="item active" id="status" style="display: none;"></div>
    <div class="menu right">
      <a class="item" id="openfile"><i class="book icon"></i>‡πÄ‡∏õ‡∏¥‡∏î‡∏´‡∏ô‡∏±‡∏á‡∏™‡∏∑‡∏≠</a>
      <a class="item" id="genFileList"><i class="file code outline icon"></i>‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£</a>
      <a class="item" id="addHtmlFile"><i class="plus icon"></i>‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÑ‡∏ü‡∏•‡πå html</a>
      <a class="item" id="saveFile"><i class="save icon"></i>‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏´‡∏ô‡∏±‡∏á‡∏™‡∏∑‡∏≠</a>
    </div>
  </div>
</div>

</div>
<div class="shadow"></div>
</div>

<div class="ui container">
  <div class="ui relaxed divided items">
    <div class="item">
      <div class="content bookinfo">
        <div class="header">üìù ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡∏ô‡∏±‡∏á‡∏™‡∏∑‡∏≠</div>
        <table class="ui striped table" style="border: 0px;">
          <tr>
            <td class="two wide column"><b>‡∏û‡∏≠‡∏£‡πå‡∏ï‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠</b></td>
            <td id="port" contenteditable="true"></td>
          </tr>
          <tr>
            <td class="two wide column"><b>‡πÑ‡∏≠‡∏î‡∏µ‡∏´‡∏ô‡∏±‡∏á‡∏™‡∏∑‡∏≠</b></td>
            <td id="filename"></td>
          </tr>
          <tr>
            <td><b>‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á</b></td>
            <td id="title" contenteditable="true"></td>
          </tr>
        </table>
      </div>
    </div>
    <table class="ui striped blue table">
      <thead>
        <tr>
          <th class="one wide column">‡∏•‡∏≥‡∏î‡∏±‡∏ö</th>
          <th class="four wide column">‡∏ä‡∏∑‡πà‡∏≠‡πÑ‡∏ü‡∏•‡πå</th>
          <th class="two wide column right aligned">üì¶</th>
        </tr>
      </thead>
      <tbody id="sectionlist"></tbody>
    </table>
  </div>
<div class="footer">
<div class="ui divider"></div>
<p><i>¬© 2023 Ann and contributors.<span class="info"></span></i></p>
</div>
</div>
</div>
<input type="file" id="zipfile" accept=".zip,.epub" style="width: 1px;height: 1px;overflow: hidden;">
<input type="file" id="addfile" accept=".html,.xhtml" multiple="" style="width: 1px;height: 1px;overflow: hidden;">
<script>

let importZip = false
let fileList = false
let bookId = ''
let opfxml = ''

document.querySelector('#title').addEventListener('focusout', event => {
  const name = toHtmlEntities(event.target.innerText).trim()
  opfxml = opfxml.replace(/<dc.title>(.*)<\/dc.title>/i, `<dc:title>${name}</dc:title>`)
})

openfile.onclick = (e)=>{
  document.getElementById('zipfile').click()
}

zipfile.onchange = (file) => {
  importZip = new JSZip()
  fileList = []
  const ebookfile = file.target.files[0]
  bookId = Path.filename(ebookfile.name)
  document.getElementById('filename').innerText = bookId
  setstatus('‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏ü‡∏•‡πå‡∏´‡∏ô‡∏±‡∏á‡∏™‡∏∑‡∏≠...', false)
  importZip.loadAsync(ebookfile).then(async(zip) => {
    const sectionList = document.querySelector('#sectionlist')
    const ebookNameNode = document.querySelector('#title')
    sectionList.innerHTML = ''
    let row = 1
    Object.keys(zip.files).forEach(async(file)=>{
      if(Path.extname(file) == ".opf"){
        opffile = file
        opfxml = await zip.files[file].async('text')
        const title = /<dc.title>(.*)<\/dc.title>/i.exec(opfxml)
        if (title != null) {
          ebookNameNode.innerText = title[1]
        }
        opfxml = opfxml.replace(' linear="no"', '')
      }
      if(Path.extname(file) == ".html" || Path.extname(file) == ".xhtml"){
        fileList.push(file)
        sectionList.insertAdjacentHTML('beforeend', `
          <tr><td>${row}</td>
          <td>${file}</td>
          <td class="right aligned files" data-file="${file}">‚ùå</td><tr>`)
        row++
      }
    })
  })
  setstatus('‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏ü‡∏•‡πå‡∏´‡∏ô‡∏±‡∏á‡∏™‡∏∑‡∏≠‡πÅ‡∏•‡πâ‡∏ß...')
}
  
genFileList.onclick = async()=>{
  if(!fileList){
    setstatus('‡πÇ‡∏õ‡∏£‡∏î‡πÄ‡∏õ‡∏¥‡∏î‡πÑ‡∏ü‡∏•‡πå‡∏´‡∏ô‡∏±‡∏á‡∏™‡∏∑‡∏≠‡∏Å‡πà‡∏≠‡∏ô!');
    return
  }
  const port = document.getElementById('port').innerText
  if(port == ''){
    setstatus('‡πÇ‡∏õ‡∏£‡∏î‡∏£‡∏∞‡∏ö‡∏∏‡∏û‡∏≠‡∏£‡πå‡∏ï‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠!');
    return
  }
  let urlList = ''
  fileList.map(file => {
    urlList += `http://127.0.0.1:${port}/${bookId}/${file}\n`
  })
  const blob = new Blob([urlList], {type: 'text/plain;charset=utf-8'})
  saveAs(blob, `list-${bookId}.txt`)
  setstatus('‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÅ‡∏•‡πâ‡∏ß!');
  /*
  navigator.clipboard.writeText(urlList).then(function() {
    setstatus('‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÑ‡∏õ‡∏ó‡∏µ‡πà‡∏Ñ‡∏•‡∏¥‡∏ö‡∏ö‡∏≠‡∏£‡πå‡∏î‡πÅ‡∏•‡πâ‡∏ß!');
  }, function(err) {
    setstatus('‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à!');
  });*/
}

addHtmlFile.onclick = (e) => {
  if(!importZip){
    setstatus('‡πÇ‡∏õ‡∏£‡∏î‡πÄ‡∏õ‡∏¥‡∏î‡πÑ‡∏ü‡∏•‡πå‡∏´‡∏ô‡∏±‡∏á‡∏™‡∏∑‡∏≠‡∏Å‡πà‡∏≠‡∏ô!');
    return
  }
  document.querySelector('#addfile').click()
  addfile.onchange = (mediafiles) => addFile(mediafiles.target)
}

const addFile = async(htmlfiles)=>{
  Object.keys(htmlfiles.files).map(async(key) => {
    const file = htmlfiles.files[key]
    setstatus('‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÑ‡∏ü‡∏•‡πå ' + file.name, false);
    let htmlfile = fileList.find(a => Path.filename(a) == Path.filename(file.name))
    const filesCheck = document.querySelectorAll('.files')
    if(htmlfile){
      filesCheck.forEach(ck=>{
        if(ck.dataset.file == htmlfile) ck.innerText = '‚úîÔ∏è'
      })
      importZip.remove(htmlfile)
      let content = await new Response(file).text()
      content = content
        .replace(/style=" --USER.*;"\s/, '')
        .replace(/<(script|style).*(script|style)>/g, '')
        .replace(/<link.*href="\/styles\/.*css"\/>/g, '')
        .replace(/<link.*href="\/CustomCss\/.*css.*\/>/g, '')
        .replace(/width.*scalable=0/, '')
        .replace(/<style.*\n?.*style>/g, '')
        .replace(/(&#8203;|&#13;)/g, '')
        .split('\n')
        .map(e => e.trim())
        .filter(String)
        .join('\n')
      importZip.file(htmlfile, content)
    }
  })
  setstatus('‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÑ‡∏ü‡∏•‡πå‡πÅ‡∏•‡πâ‡∏ß');
}

saveFile.onclick = async (e) => {
  if(!importZip){
    setstatus('‡πÇ‡∏õ‡∏£‡∏î‡πÄ‡∏õ‡∏¥‡∏î‡πÑ‡∏ü‡∏•‡πå‡∏´‡∏ô‡∏±‡∏á‡∏™‡∏∑‡∏≠‡∏Å‡πà‡∏≠‡∏ô!');
    return
  }
  importZip.remove(opffile)
  importZip.remove('META-INF/encryption.xml')
  importZip.remove('META-INF/license.lcpl')
  importZip.remove('META-INF/calibre_bookmarks.txt')
  importZip.remove('iTunesMetadata.plist')
  importZip.file(opffile, opfxml)
  importZip.generateAsync({
    type: 'blob',
    mimeType: 'application/epub+zip',
    compression: 'DEFLATE',
    compressionOptions: {level: 9}
  }, (progress) => {
    const file = progress.currentFile ? Path.basename(progress.currentFile) : ''
    setstatus('‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå...' + progress.percent.toFixed(2) + '% (‡πÑ‡∏ü‡∏•‡πå ' + file + ')', false)
  }).then((blob) => {
    setstatus('‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå‡∏´‡∏ô‡∏±‡∏á‡∏™‡∏∑‡∏≠‡πÅ‡∏•‡πâ‡∏ß...')
    const ebookName = document.querySelector('#title').innerText.trim()
    saveAs(blob, ebookName + '.epub')
  })
}

const Path = {
  dirname (pathname) {
    const part = pathname.split('/').slice(0, -1).join('/')
    return (part.length) ? part + '/' : part
  },
  basename (pathname) {
    return pathname.split('\\').pop().split('/').pop()
  },
  filename (pathname) {
    return this.basename(pathname).split('.').slice(0, -1).join('.')
  },
  extname (pathname) {
    return '.' + pathname.split('.').pop()
  },
  join (...args) {
    return args.map((part, i) => {
      if (typeof part === 'undefined' || part == false) return ''
      if (i === 0) {
        return part.trim().replace(/[\/]*$/g, '')
      } else {
        return part.trim().replace(/(^[\/]*|[\/]*$)/g, '')
      }
    }).filter(x => x.length).join('/')
  }
}

toHtmlEntities = str => str.toString()
  .replace(/[&<>]/g,match => ({
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;'
  }[match])
)

const setstatus = (str, hide = true) => {
  str = 'üì¢ <span>' + str + '</span>'
  const status = document.querySelector('#status')
  status.style.display = 'block'
  status.innerHTML = str
  if (hide) {
    setTimeout(() => {
      status.style.display = 'none'
    }, 1000)
  }
}

</script>
</body>
</html>
